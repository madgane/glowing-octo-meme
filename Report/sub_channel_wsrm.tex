
The complexity of the \ac{JSFRA} algorithm scales with the number of sub-channels considered. In addition, the iterations required for the algorithm convergence increases with the problem size. To overcome the complexity, we can adopt the distributed approaches presented in \cite{palomar2006tutorial,boyd2011distributed} for sub-channel wise precoder design using primal or dual decomposition. 

As an alternative sub-optimal solution, we present \acl{QM} \ac{SRA}, which designs the precoders independently across the sub-channels in a sequential manner using the unserviced  number of packets after each sub-channel allocation. The \ac{BS} transmit power is fixed across the sub-channel \me{n} as \me{P_{\max,n}}. The power sharing can be equal or based on predetermined pattern as in partial frequency reuse across the sub-channels. After fixing the power and the backlogged packets for a sub-channel \me{i}, precoders are determined using the \ac{JSFRA} algorithm presented in Section \ref{sec-3.2.1} or \ref{sec-3.3} for each sub-channel in a sequential manner. Once the precoders and the corresponding rates are identified, the unserviced backlogged packets for the next sub-channel \me{i+1} is updated for user \me{k} as
\begin{equation}	\label{eqn-weight}
	Q_{k,i+1} = \max{\left \lbrace Q_k - \sum_{j = 1}^{i} \, \sum_{l = 1}^{L} \, t_{l,k,j} ,0 \right \rbrace }, \; \forall \; k \in \mathcal{U},
\end{equation}
where \me{t_{l,k,j}} denotes the rate corresponding to the user \me{k} on the \me{\ith{j}} sub-channel and \me{\ith{l}} spatial stream and the initial values are given as \me{Q_{k,1} = Q_k, \forall k}. Note that the proposed scheme is sensitive to the order of the sub-channel selection due to the sequential precoder design for each sub-channel. However, the \ac{SRA} approach provides faster convergence in contrast to the \ac{JSFRA} formulation due to the substantial reduction in the optimization variables for each sub-channel problem. 
As the number of user increases, the \ac{SRA} formulation will be insusceptible to the sub-channel ordering due to the channel hardening and the availability of users with all possible channel vectors.
%The algorithmic representation of the \ac{SRA} scheme is shown in Algorithm \ref{algo-5}
%\begin{algorithm}
% \SetAlgoLined
% \DontPrintSemicolon
% \BlankLine
% \SetKwInput{KwInit}{Initialize}
% \KwIn{\me{a_k, \, Q_k, \, \mvec{H}{b,k,n},\; \fall b \in \mathcal{B}, \, \fall k \in \mathcal{U}}}
% \KwIn{permute \me{\mathcal{N} \rightarrow \tilde{\mathcal{N}}}}
% \For{\me{n \leftarrow 1 } \KwTo \me{N}}{
% update \me{Q_{k,n}} using \eqref{eqn-weight} and let \me{\hat{n} = \tilde{\mathcal{N}}(n)}\;
% \KwOut{\me{\mvec{m}{l,k,\hat{n}}} and \me{\mvec{w}{l,k,\hat{n}} \fall l \in \set{1,2,\dotsc,L}}}
% \KwInit{\me{i=0} and \me{\tilde{\mbf{m}}_{l,k,\hat{n}}} randomly satisfying per sub-channel power constraint \me{P_{\max,\hat{n}}}}
% update \me{\mvec{w}{l,k,\hat{n}}} and \me{\tilde{\mbf{u}}_{l,k,\hat{n}}} using \eqref{eqn-10} and \eqref{eqn-8}\;
% \Repeat{Queue convergence or \me{i \geq I_{\max}}}{
% initialize \me{j = 0}\;
% \Repeat{\ac{SCA} convergence or \me{j \geq J_{\max}}}{
% solve for \me{\mvec{m}{l,k,\hat{n}}} using \eqref{eqn-9} with per sub-channel power constraint \me{P_{\max,\hat{n}}}\;
% update the constraint set \eqref{eqn-8} with \me{\tilde{u}_{l,k,\hat{n}}} and \me{\mvec{m}{l,k,\hat{n}}} using \eqref{eqn-wsrm-expr}\;
% $j = j + 1$\;
% }
% update \me{\mvec{w}{l,k,n}} using \eqref{eqn-10} with the updated precoders \me{\mvec{m}{l,k,n}}\;
% $i = i + 1$\;
% }
% }
% \caption{Algorithm of \acs{SRA} scheme}
% \label{algo-5}
%\end{algorithm}
%
