The complexity of the \ac{JSFRA} algorithm scales quickly with the number of sub-channels, since the complexity of an interior point method, which is used to solve the problem, increases with the problem size. Thus, we can use the decomposition methods presented in \cite{palomar2006tutorial,boyd2011distributed} to overcome this complexity by designing precoders for each sub-channels independently with minimal information exchange.

As an alternative sub-optimal solution, we present a \acl{QM} \ac{SRA}, which solves for the precoders using \ac{JSFRA} formulation for a specific sub-channel \me{i} with a fixed transmit power \me{P_{\max,i}}. The power sharing can either be equal or based on some predetermined limits on each sub-channel as in partial frequency reuse as
\begin{equation}
\sum_{i=1}^N P_{\max,i} = P_{\max}.
\end{equation}
Even though \me{N} sub-channels are present at any given scheduling instant, precoders are computed for each sub-channel sequentially with \me{P_{\max,i}} and the residual number of backlogged packets. Let \me{Q_{k,i}} be the number of backlogged packets associated with user \me{k} while determining the precoders for the \eqn{\ith{i}} sub-channel. Since the precoder design is sequential, \textit{i.e}, the precoders are designed for sub-channels \me{[0,i-1]} before the \me{\ith{i}} sub-channel, the number of backlogged packets for the initial sub-channel is initialized as \me{Q_{k,1} = Q_k}. The queues associated with the consecutive sub-channels are given by
\begin{equation}	\label{eqn-weight}
	Q_{k,i+1} = \max \Big ( Q_k - \sum_{j = 1}^{i} \, \sum_{l = 1}^{L} \, t_{l,k,j} ,0 \Big ) \; \forall \; k \in \mathcal{U}
\end{equation}
where \me{t_{l,k,j}} is the \me{\ith{k}} user rate on sub-channel \me{j}. 

\review{For simplicity we use random sub-channel ordering in our paper, \textit{i.e.}, after finding the precoders for a current sub-channel, we can choose any previously unselected sub-channels as the next candidate sub-channel for which the precoders are identified using the updated backlogged packets. We can also use greedy ordering by considering the norm of the channel between a user and the corresponding serving \ac{BS}, but this comes at the cost of increased complexity. However, as the number of users in the system increases, the \ac{SRA} scheme will be insensitive to the sub-channel ordering due to the available multi-user diversity.}

%The algorithmic representation of the \ac{SRA} scheme is shown in Algorithm \ref{algo-5}
%\begin{algorithm}
% \SetAlgoLined
% \DontPrintSemicolon
% \BlankLine
% \SetKwInput{KwInit}{Initialize}
% \KwIn{\me{a_k, \, Q_k, \, \mvec{H}{b,k,n},\; \fall b \in \mathcal{B}, \, \fall k \in \mathcal{U}}}
% \KwIn{permute \me{\mathcal{N} \rightarrow \tilde{\mathcal{N}}}}
% \For{\me{n \leftarrow 1 } \KwTo \me{N}}{
% update \me{Q_{k,n}} using \eqref{eqn-weight} and let \me{\hat{n} = \tilde{\mathcal{N}}(n)}\;
% \KwOut{\me{\mvec{m}{l,k,\hat{n}}} and \me{\mvec{w}{l,k,\hat{n}} \fall l \in \set{1,2,\dotsc,L}}}
% \KwInit{\me{i=0} and \me{\tilde{\mbf{m}}_{l,k,\hat{n}}} randomly satisfying per sub-channel power constraint \me{P_{\max,\hat{n}}}}
% update \me{\mvec{w}{l,k,\hat{n}}} and \me{\tilde{\mbf{u}}_{l,k,\hat{n}}} using \eqref{eqn-10} and \eqref{eqn-8}\;
% \Repeat{Queue convergence or \me{i \geq I_{\max}}}{
% initialize \me{j = 0}\;
% \Repeat{\ac{SCA} convergence or \me{j \geq J_{\max}}}{
% solve for \me{\mvec{m}{l,k,\hat{n}}} using \eqref{eqn-9} with per sub-channel power constraint \me{P_{\max,\hat{n}}}\;
% update the constraint set \eqref{eqn-8} with \me{\tilde{u}_{l,k,\hat{n}}} and \me{\mvec{m}{l,k,\hat{n}}} using \eqref{eqn-wsrm-expr}\;
% $j = j + 1$\;
% }
% update \me{\mvec{w}{l,k,n}} using \eqref{eqn-10} with the updated precoders \me{\mvec{m}{l,k,n}}\;
% $i = i + 1$\;
% }
% }
% \caption{Algorithm of \acs{SRA} scheme}
% \label{algo-5}
%\end{algorithm}
%
