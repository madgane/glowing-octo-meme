
The complexity involved in the \ac{JSFRA} scheme scales significantly with the increase in the number of sub-channels considered in the formulation. In addition to the increased complexity, the rate of convergence to the optimal precoders also degrades due to its dependency on the problem size. In order to mitigate this, we can adopt the decomposition techniques discussed in \cite{palomar2006tutorial,boyd2011distributed} to distribute the precoder design across each sub-channels independently with some coupling parameters that are exchanged across the sub-channel wise subproblems. 

As an alternative sub-optimal solution, we propose \acl{QM} \ac{SRA}, which aims at designing the precoders independently across each sub-channel in a sequential manner by taking the current backlogged packets into account. In this approach, the transmit power is fixed across each sub-channel \me{n} as \me{P_{\max,n}} at each \ac{BS}. The power split can either follow equal sharing or any predetermined pattern as in partial frequency reuse. For the fixed sub-channel power, the \ac{JSFRA} formulation presented in Section \ref{sec-3.2.1} or \ref{sec-3.3} is performed over each sub-channel in a sequential manner. The coupling variable across the sub-channel is the total number of backlogged packets associated with each user. 
Let \me{Q_{k,n}} is the total number of queued bits used in the optimization problem carried out for the sub-channel \me{n}. Now, for the first sub-channel, \me{n=1}, the queues are given by \me{Q_{k,n=1} = Q_k}, which corresponds to the actual number of backlogged packets present in the current instant \me{i}. Using the updated number of queued packets, the \ac{JSFRA} algorithm is performed over the sub-channel \me{n=1} to obtain the rates associated with each user. Now, for \me{n=2}, the number of queued packets for each user is updated as \me{Q_{k,n=2} = Q_k - \sum_{l=0}^L t_{l,k,n=1}}. With this updated number of queued packets, the \ac{JSFRA} algorithm is performed for \me{n=1} sub-channel to obtain the optimal precoders. In general, the number of queued packets to be used for each user in a given sub-channel \me{n} is given by
\begin{equation}
Q_{k,n} = \max{\Big \lbrace Q_k - \sum_{r = 1}^{n-1} \, \sum_{l = 1}^{L} \, t_{l,k,r} ,0 \Big \rbrace }, \; \forall \; k \in \mathcal{U}.
\label{eqn-weight}
\end{equation}
In \eqref{eqn-weight}, \me{Q_k} denotes the total number of queued bits waiting to be transmitted for the user \me{k} during the current slot and \me{t_{l,k,r}} is the rate or guaranteed bits allocated over the sub-channel \me{r}. However, the proposed scheme is sensitive to the order in which the sub-channels are selected for the optimization problem.

The proposed \ac{QM} \ac{SRA} scheme depend on the choice of the sub-channel selection, which is evident from the sequential approach used in the sub-optimal problem formulation. However, the proposed approach provides faster convergence in contrast to the \ac{JSFRA} formulation over all sub-channel mainly due to the reduction in the size of the sub-channel wise sub problem. The choice of the sub-channel selection is random and it is difficult to determine the order, since the optimization variables \me{\mvec{m}{l,k,n}} are vectors.
%The algorithmic representation of the \ac{SRA} scheme is shown in Algorithm \ref{algo-5}
%\begin{algorithm}
% \SetAlgoLined
% \DontPrintSemicolon
% \BlankLine
% \SetKwInput{KwInit}{Initialize}
% \KwIn{\me{a_k, \, Q_k, \, \mvec{H}{b,k,n},\; \fall b \in \mathcal{B}, \, \fall k \in \mathcal{U}}}
% \KwIn{permute \me{\mathcal{N} \rightarrow \tilde{\mathcal{N}}}}
% \For{\me{n \leftarrow 1 } \KwTo \me{N}}{
% update \me{Q_{k,n}} using \eqref{eqn-weight} and let \me{\hat{n} = \tilde{\mathcal{N}}(n)}\;
% \KwOut{\me{\mvec{m}{l,k,\hat{n}}} and \me{\mvec{w}{l,k,\hat{n}} \fall l \in \set{1,2,\dotsc,L}}}
% \KwInit{\me{i=0} and \me{\tilde{\mbf{m}}_{l,k,\hat{n}}} randomly satisfying per sub-channel power constraint \me{P_{\max,\hat{n}}}}
% update \me{\mvec{w}{l,k,\hat{n}}} and \me{\tilde{\mbf{u}}_{l,k,\hat{n}}} using \eqref{eqn-10} and \eqref{eqn-8}\;
% \Repeat{Queue convergence or \me{i \geq I_{\max}}}{
% initialize \me{j = 0}\;
% \Repeat{\ac{SCA} convergence or \me{j \geq J_{\max}}}{
% solve for \me{\mvec{m}{l,k,\hat{n}}} using \eqref{eqn-9} with per sub-channel power constraint \me{P_{\max,\hat{n}}}\;
% update the constraint set \eqref{eqn-8} with \me{\tilde{u}_{l,k,\hat{n}}} and \me{\mvec{m}{l,k,\hat{n}}} using \eqref{eqn-wsrm-expr}\;
% $j = j + 1$\;
% }
% update \me{\mvec{w}{l,k,n}} using \eqref{eqn-10} with the updated precoders \me{\mvec{m}{l,k,n}}\;
% $i = i + 1$\;
% }
% }
% \caption{Algorithm of \acs{SRA} scheme}
% \label{algo-5}
%\end{algorithm}
%
